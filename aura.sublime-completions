{
    "scope": "source, comment, js",
    "completions":
    [
        { "trigger": "test.errors\t", "contents": "test.errors"},
        { "trigger": "test.addWaitFor\t(expected, testFunction, callback)", "contents": "test.addWaitFor(expected, testFunction, callback)"},
        { "trigger": "test.addWaitForAction\t(success, actionName, callback)", "contents": "test.addWaitForAction(success, actionName, callback)"},
        { "trigger": "test.addWaitForWithFailureMessage\t(expected, testFunction, failureMessage, callback)", "contents": "test.addWaitForWithFailureMessage(expected, testFunction, failureMessage, callback)"},
        { "trigger": "test.blockRequests", "contents": "test.blockRequests()"},
        { "trigger": "test.blockForegroundRequests", "contents": "test.blockForegroundRequests()"},
        { "trigger": "test.blockBackgroundRequests", "contents": "test.blockBackgroundRequests()"},
        { "trigger": "test.releaseRequests", "contents": "test.releaseRequests()"},
        { "trigger": "test.releaseForegroundRequests", "contents": "test.releaseForegroundRequests()"},
        { "trigger": "test.releaseBackgroundRequests", "contents": "test.releaseBackgroundRequests()"},
        { "trigger": "test.getSentRequestCount", "contents": "test.getSentRequestCount()"},
        { "trigger": "test.areActionsComplete\t(actions)", "contents": "test.areActionsComplete(actions)"},
        { "trigger": "test.addCleanup\t(cleanupFunction)", "contents": "test.addCleanup(cleanupFunction)"},
        { "trigger": "test.getAction\t(component, name, params, callback)", "contents": "test.getAction(component, name, params, callback)"},
        { "trigger": "test.runActionsAsTransaction\t(actions, scope, callback)", "contents": "test.runActionsAsTransaction(actions, scope, callback)"},
        { "trigger": "test.enqueueAction\t(action, background)", "contents": "test.enqueueAction(action, background)"},
        { "trigger": "test.getExternalAction\t(component, descriptor, params, returnType, callback)", "contents": "test.getExternalAction(component, descriptor, params, returnType, callback)"},
        { "trigger": "test.clearAndAssertComponentConfigs\t(a)", "contents": "test.clearAndAssertComponentConfigs(a)"},
        { "trigger": "test.isActionPending", "contents": "test.isActionPending()"},
        { "trigger": "test.callServerAction\t(action, doImmediate)", "contents": "test.callServerAction(action, doImmediate)"},
        { "trigger": "test.setServerReachable\t(reachable)", "contents": "test.setServerReachable(reachable)"},
        { "trigger": "test.runAfterIf\t(conditionFunction, callback, intervalInMs)", "contents": "test.runAfterIf(conditionFunction, callback, intervalInMs)"},
        { "trigger": "test.setTestTimeout\t(timeoutMsec)", "contents": "test.setTestTimeout(timeoutMsec)"},
        { "trigger": "test.isComplete", "contents": "test.isComplete()"},
        { "trigger": "test.getErrors", "contents": "test.getErrors()"},
        { "trigger": "test.print\t(value)", "contents": "test.print(value)"},
        { "trigger": "test.auraError\t(level, msg)", "contents": "test.auraError(level, msg)"},
        { "trigger": "test.expectAuraError\t(e)", "contents": "test.expectAuraError(e)"},
        { "trigger": "test.auraWarning\t(level, msg)", "contents": "test.auraWarning(level, msg)"},
        { "trigger": "test.expectAuraWarning\t(w)", "contents": "test.expectAuraWarning(w)"},
        { "trigger": "test.assertAccessible", "contents": "test.assertAccessible()"},
        { "trigger": "test.assertTruthy\t(condition, assertMessage)", "contents": "test.assertTruthy(condition, assertMessage)"},
        { "trigger": "test.assertFalsy\t(condition, assertMessage)", "contents": "test.assertFalsy(condition, assertMessage)"},
        { "trigger": "test.assert\t(condition, assertMessage)", "contents": "test.assert(condition, assertMessage)"},
        { "trigger": "test.assertEquals\t(arg1, arg2, assertMessage)", "contents": "test.assertEquals(arg1, arg2, assertMessage)"},
        { "trigger": "test.assertEqualsIgnoreWhitespace\t(arg1, arg2, assertMessage)", "contents": "test.assertEqualsIgnoreWhitespace(arg1, arg2, assertMessage)"},
        { "trigger": "test.assertStartsWith\t(start, full, assertMessage)", "contents": "test.assertStartsWith(start, full, assertMessage)"},
        { "trigger": "test.assertNotEquals\t(arg1, arg2, assertMessage)", "contents": "test.assertNotEquals(arg1, arg2, assertMessage)"},
        { "trigger": "test.assertDefined\t(condition, assertMessage)", "contents": "test.assertDefined(condition, assertMessage)"},
        { "trigger": "test.assertTrue\t(condition, assertMessage)", "contents": "test.assertTrue(condition, assertMessage)"},
        { "trigger": "test.assertFalse\t(condition, assertMessage)", "contents": "test.assertFalse(condition, assertMessage)"},
        { "trigger": "test.assertUndefined\t(condition, assertMessage)", "contents": "test.assertUndefined(condition, assertMessage)"},
        { "trigger": "test.assertNotUndefinedOrNull\t(condition, assertMessage)", "contents": "test.assertNotUndefinedOrNull(condition, assertMessage)"},
        { "trigger": "test.assertUndefinedOrNull\t(condition, assertMessage)", "contents": "test.assertUndefinedOrNull(condition, assertMessage)"},
        { "trigger": "test.assertNull\t(condition, assertMessage)", "contents": "test.assertNull(condition, assertMessage)"},
        { "trigger": "test.assertNotNull\t(condition, assertMessage)", "contents": "test.assertNotNull(condition, assertMessage)"},
        { "trigger": "test.assertAuraType\t(type, condition, assertMessage)", "contents": "test.assertAuraType(type, condition, assertMessage)"},
        { "trigger": "test.fail\t(assertMessage, extraInfoMessage)", "contents": "test.fail(assertMessage, extraInfoMessage)"},
        { "trigger": "test.getPrototype\t(instance)", "contents": "test.getPrototype(instance)"},
        { "trigger": "test.overrideFunction\t(instance, name, newFunction)", "contents": "test.overrideFunction(instance, name, newFunction)"},
        { "trigger": "test.addFunctionHandler\t(instance, name, newFunction, postProcess)", "contents": "test.addFunctionHandler(instance, name, newFunction, postProcess)"},
        { "trigger": "test.getOuterHtml\t(node)", "contents": "test.getOuterHtml(node)"},
        { "trigger": "test.getText\t(node)", "contents": "test.getText(node)"},
        { "trigger": "test.getTextByComponent\t(component)", "contents": "test.getTextByComponent(component)"},
        { "trigger": "test.getStyle\t(elem, style)", "contents": "test.getStyle(elem, style)"},
        { "trigger": "test.getNonCommentNodes\t(nodes)", "contents": "test.getNonCommentNodes(nodes)"},
        { "trigger": "test.isNodeDeleted\t(node)", "contents": "test.isNodeDeleted(node)"},
        { "trigger": "test.select", "contents": "test.select()"},
        { "trigger": "test.contains\t(testString, targetString)", "contents": "test.contains(testString, targetString)"},
        { "trigger": "test.compareValues\t(expected, actual)", "contents": "test.compareValues(expected, actual)"},
        { "trigger": "test.getActiveElement", "contents": "test.getActiveElement()"},
        { "trigger": "test.getActiveElementText", "contents": "test.getActiveElementText()"},
        { "trigger": "test.walkTheDOM\t(node, func)", "contents": "test.walkTheDOM(node, func)"},
        { "trigger": "test.getElementsByClassNameCustom\t(className, parentElement)", "contents": "test.getElementsByClassNameCustom(className, parentElement)"},
        { "trigger": "test.findChildWithClassName\t(parentElement, className)", "contents": "test.findChildWithClassName(parentElement, className)"},
        { "trigger": "test.getElementByClass\t(classname)", "contents": "test.getElementByClass(classname)"},
        { "trigger": "test.fireDomEvent\t(element, eventName, canBubble, cancelable)", "contents": "test.fireDomEvent(element, eventName, canBubble, cancelable)"},
        { "trigger": "test.clickOrTouch\t(element, canBubble, cancelable)", "contents": "test.clickOrTouch(element, canBubble, cancelable)"},
        { "trigger": "test.isInstanceOfText\t(node)", "contents": "test.isInstanceOfText(node)"},
        { "trigger": "test.isInstanceOfAnchorElement\t(element)", "contents": "test.isInstanceOfAnchorElement(element)"},
        { "trigger": "test.isInstanceOfInputElement\t(element)", "contents": "test.isInstanceOfInputElement(element)"},
        { "trigger": "test.isInstanceOfLiElement\t(element)", "contents": "test.isInstanceOfLiElement(element)"},
        { "trigger": "test.isInstanceOfParagraphElement\t(element)", "contents": "test.isInstanceOfParagraphElement(element)"},
        { "trigger": "test.isInstanceOfButtonElement\t(element)", "contents": "test.isInstanceOfButtonElement(element)"},
        { "trigger": "test.isInstanceOfImageElement\t(element)", "contents": "test.isInstanceOfImageElement(element)"},
        { "trigger": "test.isInstanceOfDivElement\t(element)", "contents": "test.isInstanceOfDivElement(element)"},
        { "trigger": "test.isInstanceOfSpanElement\t(element)", "contents": "test.isInstanceOfSpanElement(element)"},
        { "trigger": "test.isInstanceOf\t(element, elementType, tag)", "contents": "test.isInstanceOf(element, elementType, tag)"},
        { "trigger": "test.objectKeys\t(obj)", "contents": "test.objectKeys(obj)"},
        { "trigger": "test.getElementAttributeValue\t(element, attributeName)", "contents": "test.getElementAttributeValue(element, attributeName)"},
        { "trigger": "test.addEventHandler\t(eventName, handler, component, insert)", "contents": "test.addEventHandler(eventName, handler, component, insert)"},
        { "trigger": "test.dummyFunction", "contents": "test.dummyFunction()"},
        { "trigger": "test.getAppCacheEvents", "contents": "test.getAppCacheEvents()"},
        { "trigger": "test.getAuraErrorMessage", "contents": "test.getAuraErrorMessage()"},
        { "trigger": "test.getAvailableXHROverride\t(config, isBackground)", "contents": "test.getAvailableXHROverride(config, isBackground)"},
        { "trigger": "test.sendOverride\t(config, auraXHR, actions, method, options)", "contents": "test.sendOverride(config, auraXHR, actions, method, options)"},
        { "trigger": "test.decodeOverride\t(config, response, noStrip)", "contents": "test.decodeOverride(config, response, noStrip)"},
        { "trigger": "test.PrePostConfig\t (action, preSendCallback, postSendCallback)", "contents": "test.PrePostConfig(action, preSendCallback, postSendCallback)"},
        { "trigger": "test.addPrePostSendCallback\t (action, preSendCallback, postSendCallback)", "contents": "test.addPrePostSendCallback(action, preSendCallback, postSendCallback)"},
        { "trigger": "test.removePrePostSendCallback\t (handle)", "contents": "test.removePrePostSendCallback(handle)"},
        { "trigger": "test.install", "contents": "test.install()"},
        { "trigger": "test.run\t(name, code, timeoutOverride, quickFixException)", "contents": "test.run(name, code, timeoutOverride, quickFixException)"},
        { "trigger": "test.runInternal\t(name)", "contents": "test.runInternal(name)"},
        { "trigger": "test.executeAfterCkEditorIsReady\t(inputRichTextComponent, callback)", "contents": "test.executeAfterCkEditorIsReady(inputRichTextComponent, callback)"},
        { "trigger": "test.reloadGlobalValueProviders\t(gvp, callback)", "contents": "test.reloadGlobalValueProviders(gvp, callback)"},
        { "trigger": "test.getCreationPath\t(cmp)", "contents": "test.getCreationPath(cmp)"},
        { "trigger": "test.createHttpRequest", "contents": "test.createHttpRequest()"},
        { "trigger": "test.checkGlobalNamespacePollution", "contents": "test.checkGlobalNamespacePollution()"},
        { "trigger": "test.orderedEncode\t(obj)", "contents": "test.orderedEncode(obj)"},
        { "trigger": "util.isIE", "contents": "A.util.isIE()"},
        { "trigger": "util.isIOSWebView", "contents": "A.util.isIOSWebView()"},
        { "trigger": "util.globalEval", "contents": "A.util.globalEval()"},
        { "trigger": "util.isArray", "contents": "A.util.isArray()"},
        { "trigger": "util.isObject\t(obj)", "contents": "A.util.isObject(obj)"},
        { "trigger": "util.isPlainObject\t(obj)", "contents": "A.util.isPlainObject(obj)"},
        { "trigger": "util.isError\t(obj)", "contents": "A.util.isError(obj)"},
        { "trigger": "util.isFunction\t(obj)", "contents": "A.util.isFunction(obj)"},
        { "trigger": "util.isString\t(obj)", "contents": "A.util.isString(obj)"},
        { "trigger": "util.isNumber\t(obj)", "contents": "A.util.isNumber(obj)"},
        { "trigger": "util.isFiniteNumber\t(obj)", "contents": "A.util.isFiniteNumber(obj)"},
        { "trigger": "util.isBoolean\t(obj)", "contents": "A.util.isBoolean(obj)"},
        { "trigger": "util.isUndefined\t(obj)", "contents": "A.util.isUndefined(obj)"},
        { "trigger": "util.isUndefinedOrNull\t(obj)", "contents": "A.util.isUndefinedOrNull(obj)"},
        { "trigger": "util.isEmpty\t(obj)", "contents": "A.util.isEmpty(obj)"},
        { "trigger": "util.getBooleanValue\t (val)", "contents": "A.util.getBooleanValue(val)"},
        { "trigger": "util.createHtmlElement\t (tagName, attributes)", "contents": "A.util.createHtmlElement(tagName, attributes)"},
        { "trigger": "util.clearNode\t (node)", "contents": "A.util.clearNode(node)"},
        { "trigger": "util.getElement\t(id)", "contents": "A.util.getElement(id)"},
        { "trigger": "util.copy\t(value)", "contents": "A.util.copy(value)"},
        { "trigger": "util.compareValues\t(expected, actual)", "contents": "A.util.compareValues(expected, actual)"},
        { "trigger": "util.hasClass\t(element, className)", "contents": "A.util.hasClass(element, className)"},
        { "trigger": "util.addClass\t(element, newClass)", "contents": "A.util.addClass(element, newClass)"},
        { "trigger": "util.removeClass\t(element, newClass)", "contents": "A.util.removeClass(element, newClass)"},
        { "trigger": "util.toggleClass\t(element, className, condition)", "contents": "A.util.toggleClass(element, className, condition)"},
        { "trigger": "util.swapClass\t(element, oldClass, newClass)", "contents": "A.util.swapClass(element, oldClass, newClass)"},
        { "trigger": "util.setClass\t(element,newClass,remove)", "contents": "A.util.setClass(element,newClass,remove)"},
        { "trigger": "util.buildClass\t(oldClass, newClass, remove)", "contents": "A.util.buildClass(oldClass, newClass, remove)"},
        { "trigger": "util.buildFlavorClass\t(cmp, flavor)", "contents": "A.util.buildFlavorClass(cmp, flavor)"},
        { "trigger": "util.createElementsFromMarkup\t(markup)", "contents": "A.util.createElementsFromMarkup(markup)"},
        { "trigger": "util.insertFirst\t(newEl, referenceEl)", "contents": "A.util.insertFirst(newEl, referenceEl)"},
        { "trigger": "util.insertBefore\t(newEl, referenceEl)", "contents": "A.util.insertBefore(newEl, referenceEl)"},
        { "trigger": "util.insertAfter\t(newEl, referenceEl)", "contents": "A.util.insertAfter(newEl, referenceEl)"},
        { "trigger": "util.appendChild\t(newEl, referenceEl)", "contents": "A.util.appendChild(newEl, referenceEl)"},
        { "trigger": "util.removeElement\t(element)", "contents": "A.util.removeElement(element)"},
        { "trigger": "util.urlDecode\t(url)", "contents": "A.util.urlDecode(url)"},
        { "trigger": "util.trim\t(value)", "contents": "A.util.trim(value)"},
        { "trigger": "util.format\t(formatString,arg1,arg2,argN)", "contents": "A.util.format(formatString,arg1,arg2,argN)"},
        { "trigger": "util.truncate\t(st, len, ellipsis, truncateByWord)", "contents": "A.util.truncate(st, len, ellipsis, truncateByWord)"},
        { "trigger": "util.createTimeoutCallback\t(callback, toleranceMillis)", "contents": "A.util.createTimeoutCallback(callback, toleranceMillis)"},
        { "trigger": "util.removeOn\t(element, eventName, listener, useCapture)", "contents": "A.util.removeOn(element, eventName, listener, useCapture)"},
        { "trigger": "util.formToMap\t(form)", "contents": "A.util.formToMap(form)"},
        { "trigger": "util.getSelectValue\t(select)", "contents": "A.util.getSelectValue(select)"},
        { "trigger": "util.addValueToMap\t(inputMap, key, value)", "contents": "A.util.addValueToMap(inputMap, key, value)"},
        { "trigger": "util.addMapValueToMap\t(inputMap, key, value, subMapKey)", "contents": "A.util.addMapValueToMap(inputMap, key, value, subMapKey)"},
        { "trigger": "util.isSubDef\t(def, qname)", "contents": "A.util.isSubDef(def, qname)"},
        { "trigger": "util.apply\t( baseObject,  members,  forceCopy,  deepCopy)", "contents": "A.util.apply( baseObject,  members,  forceCopy,  deepCopy)"},
        { "trigger": "util.camelCaseToHyphens\t(str)", "contents": "A.util.camelCaseToHyphens(str)"},
        { "trigger": "util.hyphensToCamelCase\t(str)", "contents": "A.util.hyphensToCamelCase(str)"},
        { "trigger": "util.acceptsData\t(element)", "contents": "A.util.acceptsData(element)"},
        { "trigger": "util.getElementAttributeValue\t(element,attributeName)", "contents": "A.util.getElementAttributeValue(element,attributeName)"},
        { "trigger": "util.getDataAttribute\t(element, key)", "contents": "A.util.getDataAttribute(element, key)"},
        { "trigger": "util.setDataAttribute\t(element, key, value)", "contents": "A.util.setDataAttribute(element, key, value)"},
        { "trigger": "util.getDataAttributeName\t(key)", "contents": "A.util.getDataAttributeName(key)"},
        { "trigger": "util.hasDataAttribute\t(element, key)", "contents": "A.util.hasDataAttribute(element, key)"},
        { "trigger": "util.isElement\t(obj)", "contents": "A.util.isElement(obj)"},
        { "trigger": "util.attachToDocumentBody\t(element)", "contents": "A.util.attachToDocumentBody(element)"},
        { "trigger": "util.stringEndsWith\t(fullstr, substr)", "contents": "A.util.stringEndsWith(fullstr, substr)"},
        { "trigger": "util.bind", "contents": "A.util.bind()"},
        { "trigger": "util.keys", "contents": "A.util.keys()"},
        { "trigger": "util.lookup\t(object )", "contents": "A.util.lookup(object )"},
        { "trigger": "util.merge\t(first )", "contents": "A.util.merge(first )"},
        { "trigger": "util.forEach", "contents": "A.util.forEach()"},
        { "trigger": "util.map", "contents": "A.util.map()"},
        { "trigger": "util.reduce", "contents": "A.util.reduce()"},
        { "trigger": "util.every", "contents": "A.util.every()"},
        { "trigger": "util.some", "contents": "A.util.some()"},
        { "trigger": "util.filter", "contents": "A.util.filter()"},
        { "trigger": "util.destroyAsync\t(cmp)", "contents": "A.util.destroyAsync(cmp)"},
        { "trigger": "util.instanceOf\t(instance, constructor)", "contents": "A.util.instanceOf(instance, constructor)"},
        { "trigger": "util.emptyComponentTrash", "contents": "A.util.emptyComponentTrash()"},
        { "trigger": "util.contains\t(container, element)", "contents": "A.util.contains(container, element)"},
        { "trigger": "util.squash\t(event, preventDefault)", "contents": "A.util.squash(event, preventDefault)"},
        { "trigger": "util.stripTags\t(input, tags)", "contents": "A.util.stripTags(input, tags)"},
        { "trigger": "util.getWindowSize", "contents": "A.util.getWindowSize()"},
        { "trigger": "util.isComponent\t(obj)", "contents": "A.util.isComponent(obj)"},
        { "trigger": "util.isExpression\t (obj)", "contents": "A.util.isExpression(obj)"},
        { "trigger": "util.isValue\t(obj)", "contents": "A.util.isValue(obj)"},
        { "trigger": "util.isAction\t(obj)", "contents": "A.util.isAction(obj)"},
        { "trigger": "util.supportsTouchEvents", "contents": "A.util.supportsTouchEvents()"},
        { "trigger": "util.estimateSize\t(obj)", "contents": "A.util.estimateSize(obj)"},
        { "trigger": "util.toArray\t(collection)", "contents": "A.util.toArray(collection)"},
        { "trigger": "util.setText\t(node, text)", "contents": "A.util.setText(node, text)"},
        { "trigger": "util.getDebugToolComponent", "contents": "A.util.getDebugToolComponent()"},
        { "trigger": "util.getDebugToolsAuraInstance", "contents": "A.util.getDebugToolsAuraInstance()"},
        { "trigger": "util.setDebugToolWindow\t(debugWindow)", "contents": "A.util.setDebugToolWindow(debugWindow)"},
        { "trigger": "util.getUrl", "contents": "A.util.getUrl()"},
        { "trigger": "util.getText\t(node)", "contents": "A.util.getText(node)"},
        { "trigger": "util.errorBasedOnMode\t(msg)", "contents": "A.util.errorBasedOnMode(msg)"},
        { "trigger": "util.includeScript\t(url, callback)", "contents": "A.util.includeScript(url, callback)"},
    ]
}
